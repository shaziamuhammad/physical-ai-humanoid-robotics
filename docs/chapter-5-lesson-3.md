---
id: chapter-5-lesson-3
title: "Chapter 5 – Lesson 3: Mapping Plan Steps into ROS 2 Actions"
---

# Chapter 5 – Lesson 3: Mapping Plan Steps into ROS 2 Actions

## Introduction to Action Mapping

The final critical step in Vision-Language-Action (VLA) systems is mapping high-level plan steps generated by LLMs into concrete ROS 2 actions that can be executed by the robot. This lesson covers the process of translating abstract plan steps into specific ROS 2 service calls, action clients, and topic publications that control the physical robot.

## Understanding ROS 2 Action Architecture

### Action vs Service vs Topic
In ROS 2, there are three main communication patterns:

- **Topics**: Asynchronous, one-way communication for continuous data streams
- **Services**: Synchronous request/reply communication for immediate responses
- **Actions**: Asynchronous, long-running operations with feedback and cancellation

For robot control, actions are typically preferred for complex tasks that take time and may need monitoring or cancellation.

### Action Structure
ROS 2 actions have three components:
- **Goal**: What to do
- **Feedback**: Progress updates during execution
- **Result**: Final outcome when completed

## Action Mapping Framework

### Action Mapper Node
```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from rclpy.action import ActionClient
from geometry_msgs.msg import Pose, Point
from moveit_msgs.action import MoveGroup
from nav2_msgs.action import NavigateToPose
from control_msgs.action import FollowJointTrajectory
import json

class ActionMapperNode(Node):
    def __init__(self):
        super().__init__('action_mapper_node')

        # Subscribe to validated plans
        self.plan_sub = self.create_subscription(
            String,
            '/validated_execution_plan',
            self.plan_callback,
            10
        )

        # Publishers for status updates
        self.status_pub = self.create_publisher(String, '/action_mapper_status', 10)

        # Action clients for different robot capabilities
        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.moveit_client = ActionClient(self, MoveGroup, 'move_group')
        self.trajectory_client = ActionClient(self, FollowJointTrajectory, 'joint_trajectory_controller/follow_joint_trajectory')

        # Service clients for immediate operations
        self.gripper_client = self.create_client(
            SetBool,
            'gripper_controller/set_gripper'
        )

        # Action mapping dictionary
        self.action_mapping = {
            'navigate_to_location': self.execute_navigation,
            'move_arm_to_pose': self.execute_arm_movement,
            'pick_up_object': self.execute_pickup,
            'place_object': self.execute_placement,
            'grasp_object': self.execute_grasp,
            'release_object': self.execute_release,
            'move_to_joint_positions': self.execute_joint_movement
        }

        self.get_logger().info('Action Mapper initialized')

    def plan_callback(self, msg):
        """Process validated plan and execute actions"""
        try:
            plan = json.loads(msg.data)
            self.get_logger().info(f'Executing plan with {len(plan["steps"])} steps')

            # Execute plan sequentially
            for step in plan['steps']:
                success = self.execute_plan_step(step)
                if not success:
                    self.get_logger().error(f'Step execution failed: {step["description"]}')
                    break

            self.get_logger().info('Plan execution completed')

        except json.JSONDecodeError as e:
            self.get_logger().error(f'Invalid plan format: {e}')

    def execute_plan_step(self, step):
        """Execute a single plan step"""
        action = step.get('action', '')
        parameters = step.get('parameters', {})

        self.get_logger().info(f'Executing step: {action} with params: {parameters}')

        # Map action to appropriate execution method
        if action in self.action_mapping:
            try:
                success = self.action_mapping[action](parameters)
                return success
            except Exception as e:
                self.get_logger().error(f'Action execution failed: {e}')
                return False
        else:
            self.get_logger().error(f'Unknown action: {action}')
            return False

    def execute_navigation(self, params):
        """Execute navigation action"""
        goal_msg = NavigateToPose.Goal()

        # Set target pose
        goal_msg.pose.header.frame_id = params.get('frame_id', 'map')
        goal_msg.pose.pose.position.x = params.get('x', 0.0)
        goal_msg.pose.pose.position.y = params.get('y', 0.0)
        goal_msg.pose.pose.position.z = params.get('z', 0.0)

        # Set orientation (default to facing forward)
        orientation = params.get('orientation', [0, 0, 0, 1])  # w, x, y, z quaternion
        goal_msg.pose.pose.orientation.w = orientation[0]
        goal_msg.pose.pose.orientation.x = orientation[1]
        goal_msg.pose.pose.orientation.y = orientation[2]
        goal_msg.pose.pose.orientation.z = orientation[3]

        # Wait for action server
        self.nav_client.wait_for_server()

        # Send goal
        goal_future = self.nav_client.send_goal_async(goal_msg)

        # Wait for result
        rclpy.spin_until_future_complete(self, goal_future)

        goal_handle = goal_future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Navigation goal rejected')
            return False

        # Get result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)

        result = result_future.result().result
        return result is not None

    def execute_arm_movement(self, params):
        """Execute arm movement using MoveIt"""
        goal_msg = MoveGroup.Goal()

        # Configure MoveGroup goal for arm movement
        goal_msg.request.group_name = params.get('group', 'arm')
        goal_msg.request.max_velocity_scaling_factor = params.get('max_velocity', 0.5)
        goal_msg.request.max_acceleration_scaling_factor = params.get('max_acceleration', 0.5)

        # Set target pose if provided
        if 'target_pose' in params:
            target_pose = Pose()
            target_pose.position.x = params['target_pose']['x']
            target_pose.position.y = params['target_pose']['y']
            target_pose.position.z = params['target_pose']['z']
            target_pose.orientation.w = params['target_pose']['orientation']['w']
            target_pose.orientation.x = params['target_pose']['orientation']['x']
            target_pose.orientation.y = params['target_pose']['orientation']['y']
            target_pose.orientation.z = params['target_pose']['orientation']['z']

            # Add pose constraint to request
            # (This is simplified - actual MoveIt usage is more complex)
            pass

        # Wait for action server
        self.moveit_client.wait_for_server()

        # Send goal
        goal_future = self.moveit_client.send_goal_async(goal_msg)
        rclpy.spin_until_future_complete(self, goal_future)

        goal_handle = goal_future.result()
        if not goal_handle.accepted:
            self.get_logger().error('MoveGroup goal rejected')
            return False

        # Get result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)

        result = result_future.result().result
        return result is not None

    def execute_pickup(self, params):
        """Execute object pickup sequence"""
        object_name = params.get('object_name', '')
        approach_distance = params.get('approach_distance', 0.1)

        self.get_logger().info(f'Attempting to pickup {object_name}')

        # 1. Navigate to object location
        nav_params = {
            'x': params.get('x', 0.0),
            'y': params.get('y', 0.0),
            'z': params.get('z', 0.0),
            'frame_id': params.get('frame_id', 'map')
        }

        if not self.execute_navigation(nav_params):
            self.get_logger().error('Navigation to object failed')
            return False

        # 2. Position arm for pickup
        arm_params = {
            'target_pose': {
                'x': params.get('x', 0.0) - approach_distance,
                'y': params.get('y', 0.0),
                'z': params.get('z', 0.0) + 0.1,  # Slightly above object
                'orientation': {'w': 1.0, 'x': 0.0, 'y': 0.0, 'z': 0.0}
            }
        }

        if not self.execute_arm_movement(arm_params):
            self.get_logger().error('Arm positioning failed')
            return False

        # 3. Close gripper
        if not self.execute_grasp({}):
            self.get_logger().error('Grasping failed')
            return False

        # 4. Lift object
        lift_params = {
            'target_pose': {
                'x': params.get('x', 0.0) - approach_distance,
                'y': params.get('y', 0.0),
                'z': params.get('z', 0.0) + 0.3,  # Lift 30cm
                'orientation': {'w': 1.0, 'x': 0.0, 'y': 0.0, 'z': 0.0}
            }
        }

        if not self.execute_arm_movement(lift_params):
            self.get_logger().error('Lifting failed')
            return False

        self.get_logger().info(f'Successfully picked up {object_name}')
        return True

    def execute_placement(self, params):
        """Execute object placement"""
        target_x = params.get('x', 0.0)
        target_y = params.get('y', 0.0)
        target_z = params.get('z', 0.0)

        # 1. Navigate to placement location
        nav_params = {
            'x': target_x,
            'y': target_y,
            'z': target_z,
            'frame_id': params.get('frame_id', 'map')
        }

        if not self.execute_navigation(nav_params):
            self.get_logger().error('Navigation to placement location failed')
            return False

        # 2. Position arm for placement
        place_params = {
            'target_pose': {
                'x': target_x,
                'y': target_y,
                'z': target_z + 0.1,  # Slightly above placement spot
                'orientation': {'w': 1.0, 'x': 0.0, 'y': 0.0, 'z': 0.0}
            }
        }

        if not self.execute_arm_movement(place_params):
            self.get_logger().error('Arm positioning for placement failed')
            return False

        # 3. Open gripper to release object
        if not self.execute_release({}):
            self.get_logger().error('Release failed')
            return False

        # 4. Retract arm
        retract_params = {
            'target_pose': {
                'x': target_x,
                'y': target_y,
                'z': target_z + 0.3,  # Retract upward
                'orientation': {'w': 1.0, 'x': 0.0, 'y': 0.0, 'z': 0.0}
            }
        }

        if not self.execute_arm_movement(retract_params):
            self.get_logger().error('Arm retraction failed')
            return False

        self.get_logger().info('Object placement completed successfully')
        return True

    def execute_grasp(self, params):
        """Execute gripper grasp action"""
        # Wait for service server
        while not self.gripper_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Gripper service not available, waiting...')

        # Create request
        request = SetBool.Request()
        request.data = True  # Close gripper

        # Call service
        future = self.gripper_client.call_async(request)
        rclpy.spin_until_future_complete(self, future)

        response = future.result()
        if response is not None and response.success:
            self.get_logger().info('Gripper grasp successful')
            return True
        else:
            self.get_logger().error('Gripper grasp failed')
            return False

    def execute_release(self, params):
        """Execute gripper release action"""
        # Wait for service server
        while not self.gripper_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Gripper service not available, waiting...')

        # Create request
        request = SetBool.Request()
        request.data = False  # Open gripper

        # Call service
        future = self.gripper_client.call_async(request)
        rclpy.spin_until_future_complete(self, future)

        response = future.result()
        if response is not None and response.success:
            self.get_logger().info('Gripper release successful')
            return True
        else:
            self.get_logger().error('Gripper release failed')
            return False

    def execute_joint_movement(self, params):
        """Execute joint trajectory movement"""
        joint_names = params.get('joint_names', [])
        joint_positions = params.get('joint_positions', [])
        duration = params.get('duration', 5.0)  # seconds

        goal_msg = FollowJointTrajectory.Goal()

        # Create trajectory point
        from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint

        goal_msg.trajectory.joint_names = joint_names

        point = JointTrajectoryPoint()
        point.positions = joint_positions
        point.time_from_start.sec = int(duration)
        point.time_from_start.nanosec = int((duration - int(duration)) * 1e9)

        goal_msg.trajectory.points = [point]

        # Wait for action server
        self.trajectory_client.wait_for_server()

        # Send goal
        goal_future = self.trajectory_client.send_goal_async(goal_msg)
        rclpy.spin_until_future_complete(self, goal_future)

        goal_handle = goal_future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Joint trajectory goal rejected')
            return False

        # Get result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)

        result = result_future.result().result
        return result is not None
```

## Advanced Action Mapping with Feedback

### Feedback-Enabled Action Mapper
```python
class FeedbackActionMapperNode(ActionMapperNode):
    def __init__(self):
        super().__init__()

        # Publishers for feedback
        self.feedback_pub = self.create_publisher(String, '/action_feedback', 10)
        self.progress_pub = self.create_publisher(String, '/action_progress', 10)

        # Action result tracking
        self.active_goals = {}

    def execute_plan_step(self, step):
        """Execute a single plan step with feedback"""
        action = step.get('action', '')
        parameters = step.get('parameters', {})
        step_id = step.get('id', 0)

        # Publish step start feedback
        self.publish_feedback({
            'step_id': step_id,
            'status': 'started',
            'action': action,
            'timestamp': self.get_clock().now().to_msg()
        })

        # Execute with progress tracking
        success = self.execute_with_progress_tracking(step, parameters)

        # Publish step completion feedback
        self.publish_feedback({
            'step_id': step_id,
            'status': 'completed' if success else 'failed',
            'action': action,
            'success': success,
            'timestamp': self.get_clock().now().to_msg()
        })

        return success

    def execute_with_progress_tracking(self, step, params):
        """Execute action with progress tracking"""
        action = step.get('action', '')

        if action == 'navigate_to_location':
            return self.execute_navigation_with_feedback(step, params)
        elif action == 'move_arm_to_pose':
            return self.execute_arm_movement_with_feedback(step, params)
        elif action in self.action_mapping:
            # For other actions, use the base implementation
            return self.action_mapping[action](params)
        else:
            self.get_logger().error(f'Unknown action: {action}')
            return False

    def execute_navigation_with_feedback(self, step, params):
        """Execute navigation with progress feedback"""
        goal_msg = NavigateToPose.Goal()

        # Set target pose
        goal_msg.pose.header.frame_id = params.get('frame_id', 'map')
        goal_msg.pose.pose.position.x = params.get('x', 0.0)
        goal_msg.pose.pose.position.y = params.get('y', 0.0)
        goal_msg.pose.pose.position.z = params.get('z', 0.0)

        # Set orientation
        orientation = params.get('orientation', [0, 0, 0, 1])
        goal_msg.pose.pose.orientation.w = orientation[0]
        goal_msg.pose.pose.orientation.x = orientation[1]
        goal_msg.pose.pose.orientation.y = orientation[2]
        goal_msg.pose.pose.orientation.z = orientation[3]

        # Wait for action server
        self.nav_client.wait_for_server()

        # Send goal with feedback callback
        goal_future = self.nav_client.send_goal_async(
            goal_msg,
            feedback_callback=self.navigation_feedback_callback
        )

        rclpy.spin_until_future_complete(self, goal_future)

        goal_handle = goal_future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Navigation goal rejected')
            return False

        # Get result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)

        result = result_future.result().result
        return result is not None

    def navigation_feedback_callback(self, feedback_msg):
        """Handle navigation feedback"""
        feedback_data = {
            'action': 'navigate_to_location',
            'current_pose': {
                'x': feedback_msg.current_pose.pose.position.x,
                'y': feedback_msg.current_pose.pose.position.y,
                'z': feedback_msg.current_pose.pose.position.z
            },
            'distance_remaining': feedback_msg.distance_remaining
        }

        feedback_msg_str = String()
        feedback_msg_str.data = json.dumps(feedback_data)
        self.feedback_pub.publish(feedback_msg_str)

        # Calculate and publish progress
        progress_msg = String()
        progress_msg.data = f"navigation_progress:{feedback_msg.distance_remaining:.2f}m_remaining"
        self.progress_pub.publish(progress_msg)

    def execute_arm_movement_with_feedback(self, step, params):
        """Execute arm movement with progress feedback"""
        # For MoveIt actions, we can monitor joint states for progress
        goal_msg = MoveGroup.Goal()

        goal_msg.request.group_name = params.get('group', 'arm')
        goal_msg.request.max_velocity_scaling_factor = params.get('max_velocity', 0.5)
        goal_msg.request.max_acceleration_scaling_factor = params.get('max_acceleration', 0.5)

        # Wait for action server
        self.moveit_client.wait_for_server()

        # Send goal with feedback callback
        goal_future = self.moveit_client.send_goal_async(
            goal_msg,
            feedback_callback=self.moveit_feedback_callback
        )

        rclpy.spin_until_future_complete(self, goal_future)

        goal_handle = goal_future.result()
        if not goal_handle.accepted:
            self.get_logger().error('MoveGroup goal rejected')
            return False

        # Get result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)

        result = result_future.result().result
        return result is not None

    def moveit_feedback_callback(self, feedback_msg):
        """Handle MoveIt feedback"""
        feedback_data = {
            'action': 'move_arm_to_pose',
            'state': feedback_msg.state,
            'planning_time': feedback_msg.planning_time
        }

        feedback_msg_str = String()
        feedback_msg_str.data = json.dumps(feedback_data)
        self.feedback_pub.publish(feedback_msg_str)
```

## Error Handling and Recovery

### Robust Action Execution
```python
class RobustActionMapperNode(FeedbackActionMapperNode):
    def __init__(self):
        super().__init__()

        # Error recovery configuration
        self.max_retries = 3
        self.retry_delay = 1.0  # seconds

        # Publisher for error reports
        self.error_pub = self.create_publisher(String, '/action_errors', 10)

    def execute_plan_step(self, step):
        """Execute plan step with error handling and retries"""
        action = step.get('action', '')
        parameters = step.get('parameters', {})
        step_id = step.get('id', 0)

        # Track execution attempts
        for attempt in range(self.max_retries):
            self.get_logger().info(f'Executing step {step_id}, attempt {attempt + 1}/{self.max_retries}')

            try:
                success = self.execute_single_attempt(step, parameters)

                if success:
                    self.get_logger().info(f'Step {step_id} succeeded on attempt {attempt + 1}')
                    return True
                else:
                    if attempt < self.max_retries - 1:
                        self.get_logger().warning(f'Step {step_id} failed, retrying in {self.retry_delay}s')
                        time.sleep(self.retry_delay)
                    else:
                        self.get_logger().error(f'Step {step_id} failed after {self.max_retries} attempts')
                        self.report_error(step, f'Failed after {self.max_retries} attempts')
            except Exception as e:
                error_msg = f'Exception in step {step_id}: {str(e)}'
                self.get_logger().error(error_msg)
                self.report_error(step, error_msg)

                if attempt < self.max_retries - 1:
                    time.sleep(self.retry_delay)
                else:
                    return False

        return False

    def execute_single_attempt(self, step, params):
        """Execute a single attempt of a plan step"""
        action = step.get('action', '')

        if action in self.action_mapping:
            return self.action_mapping[action](params)
        else:
            self.get_logger().error(f'Unknown action: {action}')
            return False

    def report_error(self, step, error_description):
        """Report execution error"""
        error_report = {
            'step_id': step.get('id', -1),
            'action': step.get('action', 'unknown'),
            'parameters': step.get('parameters', {}),
            'error': error_description,
            'timestamp': self.get_clock().now().to_msg()
        }

        error_msg = String()
        error_msg.data = json.dumps(error_report)
        self.error_pub.publish(error_msg)

    def execute_with_safety_checks(self, step, params):
        """Execute action with safety validations"""
        # Perform pre-execution safety checks
        if not self.validate_preconditions(step, params):
            self.get_logger().error('Preconditions not met for step')
            return False

        # Execute the action
        success = self.execute_single_attempt(step, params)

        # Perform post-execution validation if successful
        if success:
            if not self.validate_postconditions(step, params):
                self.get_logger().warning('Postconditions not met, but action reported success')
                # Decide whether to consider this a failure based on requirements
                return True  # Or False if postconditions are critical

        return success

    def validate_preconditions(self, step, params):
        """Validate preconditions before executing step"""
        action = step.get('action', '')

        # Example preconditions for different actions
        if action == 'navigate_to_location':
            # Check if navigation is safe
            target_x = params.get('x', 0.0)
            target_y = params.get('y', 0.0)

            # Check if target is in safe area
            if not self.is_safe_navigation_target(target_x, target_y):
                return False

            # Check if robot is in safe state for navigation
            if not self.is_robot_safe_for_navigation():
                return False

        elif action == 'pick_up_object':
            # Check if gripper is available
            if not self.is_gripper_available():
                return False

            # Check if arm is in safe configuration
            if not self.is_arm_safe_for_manipulation():
                return False

        return True

    def validate_postconditions(self, step, params):
        """Validate postconditions after executing step"""
        action = step.get('action', '')

        if action == 'navigate_to_location':
            # Check if robot reached target location
            target_x = params.get('x', 0.0)
            target_y = params.get('y', 0.0)

            current_pos = self.get_robot_position()
            distance = self.calculate_distance(
                current_pos.x, current_pos.y,
                target_x, target_y
            )

            # Check if within acceptable tolerance
            return distance <= 0.2  # 20cm tolerance

        elif action == 'grasp_object':
            # Check if object is actually grasped
            return self.is_object_grasped()

        return True

    def is_safe_navigation_target(self, x, y):
        """Check if navigation target is safe"""
        # Implementation would check costmap, known obstacles, etc.
        return True  # Simplified

    def is_robot_safe_for_navigation(self):
        """Check if robot is in safe state for navigation"""
        # Check battery level, joint states, etc.
        return True  # Simplified

    def is_gripper_available(self):
        """Check if gripper is available for use"""
        # Check gripper status
        return True  # Simplified

    def is_arm_safe_for_manipulation(self):
        """Check if arm is in safe configuration for manipulation"""
        # Check joint limits, collisions, etc.
        return True  # Simplified

    def get_robot_position(self):
        """Get current robot position"""
        # Implementation would use TF or odometry
        from geometry_msgs.msg import Point
        return Point(x=0.0, y=0.0, z=0.0)  # Simplified

    def calculate_distance(self, x1, y1, x2, y2):
        """Calculate 2D distance between two points"""
        return ((x2 - x1)**2 + (y2 - y1)**2)**0.5

    def is_object_grasped(self):
        """Check if object is currently grasped"""
        # Implementation would check gripper sensors
        return True  # Simplified
```

## Action Mapping for Humanoid-Specific Tasks

### Humanoid Action Mapper
```python
class HumanoidActionMapperNode(RobustActionMapperNode):
    def __init__(self):
        super().__init__()

        # Additional humanoid-specific action clients
        self.walking_client = ActionClient(self, WalkToPose, 'walking_controller/walk_to_pose')
        self.balance_client = ActionClient(self, MaintainBalance, 'balance_controller/maintain_balance')

        # Update action mapping with humanoid-specific actions
        self.action_mapping.update({
            'walk_to_location': self.execute_walking,
            'maintain_balance': self.execute_balance,
            'wave': self.execute_wave,
            'greet': self.execute_greet,
            'dance': self.execute_dance
        })

    def execute_walking(self, params):
        """Execute walking action for humanoid"""
        goal_msg = WalkToPose.Goal()

        # Set target pose for walking
        goal_msg.target_pose.header.frame_id = params.get('frame_id', 'map')
        goal_msg.target_pose.pose.position.x = params.get('x', 0.0)
        goal_msg.target_pose.pose.position.y = params.get('y', 0.0)
        goal_msg.target_pose.pose.position.z = params.get('z', 0.0)

        # Set orientation
        orientation = params.get('orientation', [0, 0, 0, 1])
        goal_msg.target_pose.pose.orientation.w = orientation[0]
        goal_msg.target_pose.pose.orientation.x = orientation[1]
        goal_msg.target_pose.pose.orientation.y = orientation[2]
        goal_msg.target_pose.pose.orientation.z = orientation[3]

        # Wait for action server
        self.walking_client.wait_for_server()

        # Send goal
        goal_future = self.walking_client.send_goal_async(goal_msg)
        rclpy.spin_until_future_complete(self, goal_future)

        goal_handle = goal_future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Walking goal rejected')
            return False

        # Get result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)

        result = result_future.result().result
        return result is not None

    def execute_balance(self, params):
        """Execute balance maintenance"""
        goal_msg = MaintainBalance.Goal()

        # Configure balance parameters
        goal_msg.enable = params.get('enable', True)
        goal_msg.duration = rclpy.duration.Duration(seconds=params.get('duration', 0))
        goal_msg.target_orientation = params.get('target_orientation', [0, 0, 0, 1])

        # Wait for action server
        self.balance_client.wait_for_server()

        # Send goal
        goal_future = self.balance_client.send_goal_async(goal_msg)
        rclpy.spin_until_future_complete(self, goal_future)

        goal_handle = goal_future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Balance goal rejected')
            return False

        # Get result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)

        result = result_future.result().result
        return result is not None

    def execute_wave(self, params):
        """Execute waving gesture"""
        # Move arm to waving position
        wave_params = {
            'group': 'right_arm',
            'target_pose': {
                'x': 0.3, 'y': 0.2, 'z': 1.2,
                'orientation': {'w': 0.707, 'x': 0.0, 'y': 0.707, 'z': 0.0}
            }
        }

        success = self.execute_arm_movement(wave_params)

        if success:
            # Add waving motion if needed
            time.sleep(2.0)  # Hold wave position

        return success

    def execute_greet(self, params):
        """Execute greeting behavior"""
        # Wave gesture
        wave_success = self.execute_wave({})

        # Optional: Say greeting if speech system available
        if 'speech_publisher' in self.__dict__:
            greeting_msg = String()
            greeting_msg.data = "Hello! Nice to meet you!"
            self.speech_publisher.publish(greeting_msg)

        return wave_success

    def execute_dance(self, params):
        """Execute simple dance routine"""
        dance_moves = params.get('moves', ['wave', 'turn', 'wave'])

        for move in dance_moves:
            if move == 'wave':
                success = self.execute_wave({})
            elif move == 'turn':
                # Navigate in a circle
                turn_params = {
                    'x': 0.0, 'y': 0.0, 'z': 0.0,
                    'orientation': [0, 0, 1, 0]  # 180 degree turn
                }
                success = self.execute_navigation(turn_params)
            else:
                self.get_logger().warn(f'Unknown dance move: {move}')
                success = True  # Continue with other moves

            if not success:
                self.get_logger().error(f'Dance move {move} failed')
                return False

            time.sleep(1.0)  # Small pause between moves

        return True
```

## Performance Optimization

### Optimized Action Mapping
```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class OptimizedActionMapperNode(HumanoidActionMapperNode):
    def __init__(self):
        super().__init__()

        # Thread pool for parallel execution of independent actions
        self.executor = ThreadPoolExecutor(max_workers=4)

        # Action optimization cache
        self.action_cache = {}

    def execute_plan_step(self, step):
        """Optimized execution with caching and parallel processing where possible"""
        # Check cache for repeated actions
        cache_key = self.generate_cache_key(step)
        if cache_key in self.action_cache:
            return self.action_cache[cache_key]

        # Execute the step
        result = super().execute_plan_step(step)

        # Cache result if appropriate
        if self.is_cacheable_action(step):
            self.action_cache[cache_key] = result

        return result

    def generate_cache_key(self, step):
        """Generate cache key for action"""
        return f"{step.get('action', '')}_{hash(str(step.get('parameters', {})))}"

    def is_cacheable_action(self, step):
        """Determine if action result can be cached"""
        action = step.get('action', '')
        # Cache simple movements, don't cache navigation or manipulation
        return action in ['move_to_joint_positions', 'move_arm_to_pose']
```

## Summary

Mapping plan steps to ROS 2 actions is the critical bridge between high-level AI planning and low-level robot control. This process involves translating abstract plan steps into specific ROS 2 communication patterns (topics, services, and actions) that control the physical robot. The mapping must consider safety, error handling, feedback, and humanoid-specific capabilities. Proper implementation of action mapping enables VLA systems to execute complex tasks like "Clean the room" by coordinating multiple robot subsystems. The next chapter will explore why Physical AI matters in the broader context of AI development.